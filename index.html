<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>libVFRendering: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div>
   <h1 id="projectname">libVFRendering
   &nbsp;<span id="projectnumber">0.1.1</span>
   </h1>
   <div id="projectbrief">A vector field rendering library</div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">libVFRendering Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>libvfrendering</b> is a C++ library for rendering vectorfields using OpenGL. Originally developed for <a href="https://github.com/spirit-code/spirit">spirit</a> and based on <a href="https://github.com/FlorianRhiem/WebGLSpins.js">WegGLSpins.js</a>, it has an extendable architecture and currently offers renderer implementations for:</p><ul>
<li>glyph-based vector field representations as arrows</li>
<li>colormapped surface and isosurface rendering</li>
<li>mapping vector directions onto a sphere</li>
</ul>
<p>The library is still very much a work-in-progress, so its API is not yet stable and there are still several features missing that will be added in later releases. If you miss a feature or have another idea on how to improve libvfrendering, please open an issue or pull request!</p>
<div class="image">
<img src="https://github.com/FlorianRhiem/VFRendering/raw/master/docs/images/demo.png"  alt="Demo" title="Demo"/>
</div>
<h2>Getting Started</h2>
<p>To use <b>libvfrendering</b>, you need to perform the following steps:</p>
<ol type="1">
<li>Include &lt;<a class="el" href="_view_8hxx_source.html">VFRendering/View.hxx</a>&gt;</li>
<li>Create a <em><a class="el" href="class_v_f_rendering_1_1_geometry.html">VFRendering::Geometry</a></em></li>
<li>Read or calculate the vector directions</li>
<li>Pass geometry and directions to a <em><a class="el" href="class_v_f_rendering_1_1_view.html">VFRendering::View</a></em></li>
<li>Draw the view in an existing OpenGL context</li>
</ol>
<h3>1. Include &lt;<a class="el" href="_view_8hxx_source.html">VFRendering/View.hxx</a>&gt;</h3>
<p>When using <b>libvfrendering</b>, you will mostly interact with View objects, so it should be enough to <code>#include &lt;<a class="el" href="_view_8hxx_source.html">VFRendering/View.hxx</a>&gt;</code>.</p>
<h3>2. Create a <a class="el" href="class_v_f_rendering_1_1_geometry.html">VFRendering::Geometry</a></h3>
<p>The <b>geometry describes the positions</b> on which you evaluated the vector field and how they might form a grid (optional, e.g. for isosurface and surface rendering). You can pass the positions directly to the constructor or call one of the class' static methods.</p>
<p>As an example, this is how you could create a simple, cartesian 30x30x30 geometry, with coordinates between -1 and 1:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto geometry = VFRendering::Geometry::cartesianGeometry(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    {30, 30, 30},</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    {-1.0, -1.0, -1.0},</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    {1.0, 1.0, 1.0}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;);</div>
</div><!-- fragment --><h3>3. Read or calculate the vector directions</h3>
<p>This step highly depends on your use case. The <b>directions are stored as a <code>std::vector&lt;glm::vec3&gt;</code></b>, so they can be created in a simple loop:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;std::vector&lt;glm::vec3&gt; directions;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;for (int iz = 0; iz &lt; 10; iz++) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    for (int iy = 0; iy &lt; 10; iy++) {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        for (int ix = 0; ix &lt; 10; ix++) {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            // calculate direction for ix, iy, iz</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            directions.push_back(glm::normalize({ix-4.5, iy-4.5, iz-4.5}));</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        }</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    }</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
</div><!-- fragment --><p>As shown here, the directions should be in <b>C order</b> when using the <code><a class="el" href="class_v_f_rendering_1_1_geometry.html">VFRendering::Geometry</a></code> static methods. If you do not know <a href="http://glm.g-truc.net/">glm</a>, think of a <code>glm::vec3</code> as a struct containing three floats x, y and z.</p>
<h3>4. Pass geometry and directions to a <a class="el" href="class_v_f_rendering_1_1_view.html">VFRendering::View</a></h3>
<p>The view object is what you will interact most with. It provides an interface to the various renderers and includes functions for handling mouse input.</p>
<p>You can <b>create a new view</b> and then <b>pass the geometry and directions by calling the update method</b>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;VFRendering::View view;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;view.update(geometry, directions);</div>
</div><!-- fragment --><p>If the directions changed but the geometry is the same, you can use the <b>updateVectors method</b>.</p>
<h3>5. Draw the view in an existing OpenGL context</h3>
<p>To actually see something, you need to create an OpenGL context using a toolkit of your choice, e.g. Qt or GLFW. After creating the context, pass the framebuffer size to the <b>setFramebufferSize method</b>. You can then call the <b>draw method</b> of the view to render the vector field, either in a loop or only when you update the data.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;view.draw();</div>
</div><!-- fragment --><p>For a complete example, including an interactive camera, see demo.cxx.</p>
<h2>Renderers</h2>
<p><b>libvfrendering</b> offers several types of renderers, which all inherit from <a class="el" href="class_v_f_rendering_1_1_renderer_base.html">VFRendering::RendererBase</a>. Most important among these are:</p>
<ul>
<li><a class="el" href="class_v_f_rendering_1_1_arrow_renderer.html">VFRendering::ArrowRenderer</a>, which renders the vectors as arrows</li>
<li><a class="el" href="class_v_f_rendering_1_1_surface_renderer.html">VFRendering::SurfaceRenderer</a>, which renders the surface of the geometry using a colormap</li>
<li><a class="el" href="class_v_f_rendering_1_1_isosurface_renderer.html">VFRendering::IsosurfaceRenderer</a>, which renders an isosurface of the vectorfield using a colormap</li>
<li><a class="el" href="class_v_f_rendering_1_1_vector_sphere_renderer.html">VFRendering::VectorSphereRenderer</a>, which renders the vectors as dots on a sphere, with the position of each dot representing the direction of the vector</li>
</ul>
<p>In addition to these, there also the following renderers:</p><ul>
<li><a class="el" href="class_v_f_rendering_1_1_combined_renderer.html">VFRendering::CombinedRenderer</a>, which can be used to create a combination of several renderers, like an isosurface rendering with arrows</li>
<li><a class="el" href="class_v_f_rendering_1_1_bounding_box_renderer.html">VFRendering::BoundingBoxRenderer</a>, which is used for rendering bounding boxes around the geometry rendered by an VFRendering::ArrorRenderer, <a class="el" href="class_v_f_rendering_1_1_surface_renderer.html">VFRendering::SurfaceRenderer</a> or <a class="el" href="class_v_f_rendering_1_1_isosurface_renderer.html">VFRendering::IsosurfaceRenderer</a></li>
<li><a class="el" href="class_v_f_rendering_1_1_coordinate_system_renderer.html">VFRendering::CoordinateSystemRenderer</a>, which is used for rendering a coordinate system, with the axes colored by using the colormap</li>
</ul>
<p>To control what renderers are used, you can use <code>VFRendering::View::renderers</code>. As a convenience function it uses one main renderer (possibly with a bounding box), one alternative smaller renderer and a coordinate system. Alternatively, you can pass it a <code>std::vector</code>s of <code>std::pair</code>s of renderers as <a class="el" href="class_v_f_rendering_1_1_renderer_base.html">VFRendering::RendererBase</a> shared pointers and viewports as <code>glm::vec4</code>.</p>
<h2>Options</h2>
<p>To modify the way the vector field is rendered, <b>libvfrendering</b> offers a variety of options. To set these, you can create an <b>VFRendering::Options</b> object.</p>
<p>As an example, to adjust the vertical field of view, you would do the following:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;VFRendering::Options options;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;options.set&lt;VFRendering::View::Option::VERTICAL_FIELD_OF_VIEW&gt;(</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    30</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;view.updateOptions(options);</div>
</div><!-- fragment --><p>If you want to set only one option, you can also use <b>View::setOption</b>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;view.setOption&lt;VFRendering::View::Option::VERTICAL_FIELD_OF_VIEW&gt;(30);</div>
</div><!-- fragment --><p>If you want to set an option for an individual Renderer, you can use the methods <b>RendererBase::updateOptions</b> and <b>RendererBase::setOption</b> in the same way.</p>
<p>Whether this way of setting options should be replaced by getters/setters will be evaluated as the API becomes more stable.</p>
<p>Currently, the following options are available:</p>
<table class="doxtable">
<tr>
<th>Index </th><th>Type </th><th>Default value </th><th>Header file </th><th>Documentation  </th></tr>
<tr>
<td>View::Option::BOUNDING_BOX_MIN </td><td>glm::vec3 </td><td>{-1, -1, -1} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_b_o_u_n_d_i_n_g___b_o_x___m_i_n_01_4" title="Option to set the position of the lower left front corner of the bounding box. ">VFRendering::Utilities::Options::Option&lt; View::Option::BOUNDING_BOX_MIN &gt;</a> </td></tr>
<tr>
<td>View::Option::BOUNDING_BOX_MAX </td><td>glm::vec3 </td><td>{1, 1, 1} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_b_o_u_n_d_i_n_g___b_o_x___m_a_x_01_4" title="Option to set the position of the upper right back corner of the bounding box. ">VFRendering::Utilities::Options::Option&lt; View::Option::BOUNDING_BOX_MAX &gt;</a> </td></tr>
<tr>
<td>View::Option::SYSTEM_CENTER </td><td>glm::vec3 </td><td>{0, 0, 0} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_s_y_s_t_e_m___c_e_n_t_e_r_01_4" title="Option to set the position of the system center. ">VFRendering::Utilities::Options::Option&lt; View::Option::SYSTEM_CENTER &gt;</a> </td></tr>
<tr>
<td>View::Option::VERTICAL_FIELD_OF_VIEW </td><td>float </td><td>45.0 </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_v_e_r_t_i_c_ab95bab0abc5ba51182e218f010b41690" title="Option to set the vertical field of view for renderers using a perspective projection. ">VFRendering::Utilities::Options::Option&lt; View::Option::VERTICAL_FIELD_OF_VIEW &gt;</a> </td></tr>
<tr>
<td>View::Option::BACKGROUND_COLOR </td><td>glm::vec3 </td><td>{0, 0, 0} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_b_a_c_k_g_r_o_u_n_d___c_o_l_o_r_01_4" title="Option to set the background color. ">VFRendering::Utilities::Options::Option&lt; View::Option::BACKGROUND_COLOR &gt;</a> </td></tr>
<tr>
<td>View::Option::COLORMAP_IMPLEMENTATION </td><td>std::string </td><td>VFRendering::Utilities::getColormapImplementation(VFRendering::Utilities::Colormap::DEFAULT) </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_c_o_l_o_r_m_a1e5d0522f7cd6870ff10fa1f355429ef" title="Option to set the GLSL code implementing the colormap function. ">VFRendering::Utilities::Options::Option&lt; View::Option::COLORMAP_IMPLEMENTATION &gt;</a> </td></tr>
<tr>
<td>View::Option::IS_VISIBLE_IMPLEMENTATION </td><td>std::string </td><td>bool is_visible(vec3 position, vec3 direction) { return true; } </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_i_s___v_i_s_icaef6a50abda602e18c9f6f53a53c3f9" title="Option to set the GLSL code implementing the is_visible function. ">VFRendering::Utilities::Options::Option&lt; View::Option::IS_VISIBLE_IMPLEMENTATION &gt;</a> </td></tr>
<tr>
<td>View::Option::CAMERA_POSITION </td><td>glm::vec3 </td><td>{14.5, 14.5, 30} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_c_a_m_e_r_a___p_o_s_i_t_i_o_n_01_4" title="Option to set the camera position. ">VFRendering::Utilities::Options::Option&lt; View::Option::CAMERA_POSITION &gt;</a> </td></tr>
<tr>
<td>View::Option::CENTER_POSITION </td><td>glm::vec3 </td><td>{14.5, 14.5, 0} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_c_e_n_t_e_r___p_o_s_i_t_i_o_n_01_4" title="Option to set the camera focus center position. ">VFRendering::Utilities::Options::Option&lt; View::Option::CENTER_POSITION &gt;</a> </td></tr>
<tr>
<td>View::Option::UP_VECTOR </td><td>glm::vec3 </td><td>{0, 1, 0} </td><td><a class="el" href="_view_8hxx_source.html">View.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_view_1_1_option_1_1_u_p___v_e_c_t_o_r_01_4" title="Option to set the camera up vector. ">VFRendering::Utilities::Options::Option&lt; View::Option::UP_VECTOR &gt;</a> </td></tr>
<tr>
<td>ArrowRenderer::Option::CONE_RADIUS </td><td>float </td><td>0.25 </td><td><a class="el" href="_arrow_renderer_8hxx_source.html">ArrowRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_arrow_renderer_1_1_option_1_1_c_o_n_e___r_a_d_i_u_s_01_4">VFRendering::Utilities::Options::Option&lt; ArrowRenderer::Option::CONE_RADIUS &gt;</a> </td></tr>
<tr>
<td>ArrowRenderer::Option::CONE_HEIGHT </td><td>float </td><td>0.6 </td><td><a class="el" href="_arrow_renderer_8hxx_source.html">ArrowRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_arrow_renderer_1_1_option_1_1_c_o_n_e___h_e_i_g_h_t_01_4">VFRendering::Utilities::Options::Option&lt; ArrowRenderer::Option::CONE_HEIGHT &gt;</a> </td></tr>
<tr>
<td>ArrowRenderer::Option::CYLINDER_RADIUS </td><td>float </td><td>0.125 </td><td><a class="el" href="_arrow_renderer_8hxx_source.html">ArrowRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_arrow_renderer_1_1_option_1_1_c_y_l_i_n_d_e_r___r_a_d_i_u_s_01_4">VFRendering::Utilities::Options::Option&lt; ArrowRenderer::Option::CYLINDER_RADIUS &gt;</a> </td></tr>
<tr>
<td>ArrowRenderer::Option::CYLINDER_HEIGHT </td><td>float </td><td>0.7 </td><td><a class="el" href="_arrow_renderer_8hxx_source.html">ArrowRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_arrow_renderer_1_1_option_1_1_c_y_l_i_n_d_e_r___h_e_i_g_h_t_01_4">VFRendering::Utilities::Options::Option&lt; ArrowRenderer::Option::CYLINDER_HEIGHT &gt;</a> </td></tr>
<tr>
<td>ArrowRenderer::Option::LEVEL_OF_DETAIL </td><td>unsigned int </td><td>20 </td><td><a class="el" href="_arrow_renderer_8hxx_source.html">ArrowRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_arrow_renderer_1_1_option_1_1_l_e_v_e_l___o_f___d_e_t_a_i_l_01_4">VFRendering::Utilities::Options::Option&lt; ArrowRenderer::Option::LEVEL_OF_DETAIL &gt;</a> </td></tr>
<tr>
<td>BoundingBoxRenderer::Option::COLOR </td><td>glm::vec3 </td><td>{1.0, 1.0, 1.0} </td><td><a class="el" href="_bounding_box_renderer_8hxx_source.html">BoundingBoxRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_bounding_box_renderer_1_1_option_1_1_c_o_l_o_r_01_4">VFRendering::Utilities::Options::Option&lt; BoundingBoxRenderer::Option::COLOR &gt;</a> </td></tr>
<tr>
<td>CoordinateSystemRenderer::Option::AXIS_LENGTH </td><td>glm::vec3 </td><td>{0.5, 0.5, 0.5} </td><td><a class="el" href="_coordinate_system_renderer_8hxx_source.html">CoordinateSystemRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_coordinate_system_renderer_1_1_ope8c8e56fd4be4b1fdbe70a9e780869dc">VFRendering::Utilities::Options::Option&lt; CoordinateSystemRenderer::Option::AXIS_LENGTH &gt;</a> </td></tr>
<tr>
<td>CoordinateSystemRenderer::Option::ORIGIN </td><td>glm::vec3 </td><td>{0.0, 0.0, 0.0} </td><td><a class="el" href="_coordinate_system_renderer_8hxx_source.html">CoordinateSystemRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_coordinate_system_renderer_1_1_option_1_1_o_r_i_g_i_n_01_4">VFRendering::Utilities::Options::Option&lt; CoordinateSystemRenderer::Option::ORIGIN &gt;</a> </td></tr>
<tr>
<td>IsosurfaceRenderer::Option::ISOVALUE </td><td>float </td><td>0.0 </td><td><a class="el" href="_isosurface_renderer_8hxx_source.html">IsosurfaceRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_isosurface_renderer_1_1_option_1_1_i_s_o_v_a_l_u_e_01_4">VFRendering::Utilities::Options::Option&lt; IsosurfaceRenderer::Option::ISOVALUE &gt;</a> </td></tr>
<tr>
<td>IsosurfaceRenderer::Option::VALUE_FUNCTION </td><td>std::function&lt;isovalue_type(const glm::vec3&amp;, const glm::vec3&amp;)&gt; </td><td>[] (const glm::vec3&amp; position, const glm::vec3&amp; direction) { return direction.z; } </td><td><a class="el" href="_isosurface_renderer_8hxx_source.html">IsosurfaceRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_isosurface_renderer_1_1_option_1_e5009119ac8eb52b98b4326f78c9e887">VFRendering::Utilities::Options::Option&lt; IsosurfaceRenderer::Option::VALUE_FUNCTION &gt;</a> </td></tr>
<tr>
<td>VectorSphereRenderer::Option::POINT_SIZE_RANGE </td><td>glm::vec2 </td><td>{1.0, 4.0} </td><td><a class="el" href="_vector_sphere_renderer_8hxx_source.html">VectorSphereRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_vector_sphere_renderer_1_1_optionb10b4eaa7a6e061b9ece42197ab3576e">VFRendering::Utilities::Options::Option&lt; VectorSphereRenderer::Option::POINT_SIZE_RANGE &gt;</a> </td></tr>
<tr>
<td>VectorSphereRenderer::Option::INNER_SPHERE_RADIUS </td><td>float </td><td>0.95 </td><td><a class="el" href="_vector_sphere_renderer_8hxx_source.html">VectorSphereRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_vector_sphere_renderer_1_1_option972b3b0729d4cc66d2e8b09e5897ba9a">VFRendering::Utilities::Options::Option&lt; VectorSphereRenderer::Option::INNER_SPHERE_RADIUS &gt;</a> </td></tr>
<tr>
<td>VectorSphereRenderer::Option::USE_SPHERE_FAKE_PERSPECTIVE </td><td>bool </td><td>true </td><td><a class="el" href="_vector_sphere_renderer_8hxx_source.html">VectorSphereRenderer.hxx</a> </td><td><a class="el" href="class_v_f_rendering_1_1_utilities_1_1_options.html#struct_v_f_rendering_1_1_utilities_1_1_options_1_1_option_3_01_vector_sphere_renderer_1_1_option333ef09585402947df1d804cf60f65ec">VFRendering::Utilities::Options::Option&lt; VectorSphereRenderer::Option::USE_SPHERE_FAKE_PERSPECTIVE &gt;</a> </td></tr>
</table>
<h2>ToDo</h2>
<ul>
<li>A <b>EGS plugin</b> for combining <b>libvfrendering</b> with existing <b>EGS</b> plugins.</li>
<li>Methods for reading geometry and directions from data files</li>
<li>Documentation</li>
</ul>
<p>See the issues for further information and adding your own requests. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
